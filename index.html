<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>æŸ´æŸ´çš„åŸºéš†æ•£æ­¥é å ±</title>

  <style>
    :root{
      --bg-1: #FFFBF3;
      --accent: #8A4D0F;
      --soft: #FFF4E6;
      --card: #fffdf8;
      --muted: #7A603D;
      --green: #7DE1A9;
    }
    body {
      margin: 0;
      padding: 0;
      font-family: "Zen Maru Gothic", "Noto Sans TC", sans-serif;
      background: repeating-linear-gradient(
        45deg,
        #f7f3e9,
        #f7f3e9 10px,
        #faf6ef 10px,
        #faf6ef 20px
      );
      color: var(--accent);
    }

    .container {
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
    }

    .status-bar {
      display:flex;
      justify-content:space-between;
      align-items:center;
      background: rgba(255,255,255,0.6);
      padding:12px 16px;
      border-radius: 12px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.05);
    }
    .location-pill{
      background:#ffedd5;
      padding:6px 12px;
      border-radius:50px;
      font-weight:900;
      transform: rotate(-2deg);
      border:2px solid white;
      box-shadow:2px 2px 0 rgba(0,0,0,0.06);
    }
    .update-pill{
      background: rgba(0,0,0,0.15);
      color:white;
      padding:6px 10px;
      border-radius:10px;
      font-size:0.9rem;
    }

    .weather-card {
      background: var(--card);
      border-radius: 24px;
      padding: 22px;
      margin-top: 18px;
      box-shadow: 0 10px 20px rgba(0,0,0,0.08);
      border: 3px solid #f0e9da;
      position: relative;
    }

    .hero-period {
      position:absolute;
      top:-14px;
      left:50%;
      transform:translateX(-50%);
      background:#4FB5D9;
      color:white;
      padding:6px 20px;
      border-radius:20px;
      font-weight:bold;
      border:3px solid white;
      box-shadow:0 4px 0 rgba(0,0,0,0.08);
    }

    .weather-main {
      text-align:center;
    }

    .weather-icon {
      font-size:64px;
      filter: drop-shadow(0 4px 0 rgba(0,0,0,0.08));
      animation: float 3s infinite;
    }
    @keyframes float {
      0%,100%{transform: translateY(0)}
      50%{transform: translateY(-8px)}
    }

    .temp { font-size:44px; font-weight:900; color:var(--accent); }
    .desc { font-size:18px; color:#8A7B70; margin-top:6px; font-weight:700; }

    .advice {
      margin-top:14px;
      padding:12px;
      background: var(--soft);
      border-radius:14px;
      border:2px dashed #f0c692;
      color:var(--accent);
      font-size:15px;
      white-space:pre-line;
    }

    .dog-walk-advice {
      margin-top:12px;
      padding:14px;
      background:#fef7ea;
      border-radius:16px;
      border:2px solid #edcfa5;
      color:var(--muted);
      font-size:15px;
      white-space:pre-line;
    }
    .dog-walk-advice-title{ font-weight:900; margin-bottom:6px; }

    .date { text-align:right; color:var(--muted); margin-top:8px; font-size:14px; }

    .section-title { font-size:18px; margin-top:18px; color:var(--accent); font-weight:900; }

    .forecast-scroll {
      display:flex;
      gap:12px;
      overflow-x:auto;
      padding:12px 4px 18px 0;
      margin-top:10px;
    }
    .forecast-card {
      min-width:140px;
      background:var(--card);
      padding:12px;
      border-radius:14px;
      border:3px solid white;
      box-shadow:0 6px 14px rgba(0,0,0,0.06);
      text-align:center;
      flex-shrink:0;
    }
    .mini-time { background:var(--green); color:white; padding:4px 8px; border-radius:10px; font-weight:900; display:inline-block; margin-bottom:8px; font-size:0.85rem; }
    .mini-icon { font-size:34px; margin:6px 0; }
    .mini-temp { font-weight:800; color:var(--muted); margin-top:6px; }
    .mini-rain { color:#666; margin-top:4px; font-size:0.9rem; }
    .forecast-walk { margin-top:8px; font-size:13px; background:#fff4e1; padding:6px 8px; border-radius:10px; border:1px dashed #d9b78c; display:inline-block; }

    /* loading */
    .loading-screen {
      position: fixed;
      inset:0;
      background: rgba(255,255,255,0.95);
      display:flex;
      align-items:center;
      justify-content:center;
      flex-direction:column;
      z-index:999;
      color: #b07a49;
      font-weight:700;
      font-size:18px;
    }

    /* small responsiveness */
    @media (max-width:420px){
      .container { padding:14px; }
      .temp { font-size:36px; }
      .weather-icon { font-size:56px; }
    }
  </style>
</head>
<body>
  <div id="loading" class="loading-screen">
    <div style="font-size:48px; margin-bottom:12px;">â˜ï¸</div>
    <div>æŸ´æŸ´æ­£åœ¨æŠ“å–åŸºéš†å¤©æ°£â€¦</div>
  </div>

  <div class="container" id="mainContent" style="display:none;">
    <div class="status-bar">
      <div class="location-pill">ğŸ“ åŸºéš†å¸‚</div>
      <div id="updateTime" class="update-pill">æ›´æ–°ä¸­...</div>
    </div>

    <div id="heroCard" class="weather-card">
      <!-- hero content ç”± JS å¡«å…¥ -->
    </div>

    <div class="date" id="todayDate"></div>

    <div class="section-title">ç¨å¾Œé å ±</div>
    <div class="forecast-scroll" id="futureForecasts"></div>
  </div>

  <script>
    // API endpoint
    const API_URL = "https://weather-tw-yc.zeabur.app/api/weather/keelung";

    // Helper: normalize various API shapes into unified forecast array
    function normalizeApiData(raw) {
      // raw might be:
      // { success: true, data: { forecasts: [...] } }
      // or { forecasts: [...] }
      // or { current: {...}, forecast: [...] }
      // or { forecast: [...] }
      // We'll produce an object { forecasts: [ { startTime, weather, minTemp, maxTemp, rain } , ... ] }

      let source = raw;
      if (raw && raw.success && raw.data) source = raw.data;

      // case: has 'forecasts'
      if (Array.isArray(source.forecasts) && source.forecasts.length) {
        // make sure keys consistent
        return {
          forecasts: source.forecasts.map(f => ({
            startTime: f.startTime || f.start || f.time || f.dt || f.datetime || "",
            weather: (f.weather || f.description || f.weatherDescription || "").toString(),
            minTemp: String(f.minTemp ?? f.min_temperature ?? f.t_min ?? f.min ?? "").replace("Â°",""),
            maxTemp: String(f.maxTemp ?? f.max_temperature ?? f.t_max ?? f.max ?? "").replace("Â°",""),
            rain: String(f.rain ?? f.pop ?? f.rainProb ?? "").replace("%",""),
          }))
        };
      }

      // case: has forecast array under other name
      if (Array.isArray(source.forecast) && source.forecast.length) {
        return {
          forecasts: source.forecast.map(f => ({
            startTime: f.start || f.startTime || "",
            weather: (f.weather || f.description || "").toString(),
            minTemp: String(f.minTemp ?? f.min ?? f.t_min ?? "").replace("Â°",""),
            maxTemp: String(f.maxTemp ?? f.max ?? f.t_max ?? "").replace("Â°",""),
            rain: String(f.rain ?? f.pop ?? "").replace("%",""),
          }))
        };
      }

      // case: sometimes API returns current and forecast separately
      if (source.current && Array.isArray(source.forecast)) {
        const merged = [source.current, ...source.forecast];
        return {
          forecasts: merged.map(f => ({
            startTime: f.start || f.startTime || "",
            weather: (f.weather || f.description || "").toString(),
            minTemp: String(f.minTemp ?? f.min ?? f.t_min ?? f.minTemp ?? "").replace("Â°",""),
            maxTemp: String(f.maxTemp ?? f.max ?? f.t_max ?? f.maxTemp ?? "").replace("Â°",""),
            rain: String(f.rain ?? f.pop ?? "").replace("%",""),
          }))
        };
      }

      // fallback: if raw itself looks like a forecast item
      if (Array.isArray(raw) && raw.length) {
        return {
          forecasts: raw.map(f => ({
            startTime: f.startTime || f.start || "",
            weather: (f.weather || f.description || "").toString(),
            minTemp: String(f.minTemp ?? f.min ?? "").replace("Â°",""),
            maxTemp: String(f.maxTemp ?? f.max ?? "").replace("Â°",""),
            rain: String(f.rain ?? f.pop ?? "").replace("%",""),
          }))
        };
      }

      // nothing matched - return empty
      return { forecasts: [] };
    }

    function getWeatherIcon(weather) {
      if (!weather) return "ğŸŒ¤ï¸";
      if (weather.includes("é›·")) return "â›ˆï¸";
      if (weather.includes("é›¨")) return "ğŸŒ§ï¸";
      if (weather.includes("å¤šé›²") || weather.includes("é›²")) return "â›…";
      if (weather.includes("é™°")) return "â˜ï¸";
      if (weather.includes("æ™´")) return "â˜€ï¸";
      return "ğŸŒ¤ï¸";
    }

    function parseNumber(n) {
      if (n === undefined || n === null || n === "") return NaN;
      const num = parseInt(String(n).replace(/[^0-9-]/g, ""), 10);
      return Number.isNaN(num) ? NaN : num;
    }

    function getTimePeriodFromStart(startTime) {
      if (!startTime) return "æ™‚æ®µ";
      const h = new Date(startTime).getHours();
      if (h >= 5 && h < 11) return "æ—©æ™¨";
      if (h >= 11 && h < 14) return "ä¸­åˆ";
      if (h >= 14 && h < 18) return "ä¸‹åˆ";
      if (h >= 18 && h < 23) return "æ™šä¸Š";
      return "æ·±å¤œ";
    }

    // Human advice (ç©¿è¡£/å¸¶å‚˜)
    function getHumanAdvice(rainProb, maxTemp) {
      const rain = parseNumber(rainProb);
      const maxT = parseNumber(maxTemp);
      let t = "";

      if (!Number.isNaN(rain)) {
        if (rain >= 70) t += "é›¨å‹¢æ˜é¡¯ï¼Œè«‹å‹™å¿…å¸¶å‚˜ï¼\n";
        else if (rain >= 40) t += "å¯èƒ½æœ‰é™£é›¨ï¼Œå»ºè­°å¸¶å‚˜ã€‚\n";
        else t += "é™é›¨æ©Ÿç‡ä½ï¼Œå¤–å‡ºåŸºæœ¬ç„¡é›¨ã€‚\n";
      } else {
        t += "é™é›¨è³‡è¨Šä¸å®Œæ•´ï¼Œå¤–å‡ºè«‹æ³¨æ„å¤©æ°£ã€‚\n";
      }

      if (!Number.isNaN(maxT)) {
        if (maxT >= 33) t += "å¤©æ°£éå¸¸ç‚ç†±ï¼Œæ³¨æ„é˜²æ›¬èˆ‡è£œæ°´ã€‚";
        else if (maxT >= 28) t += "åç†±ï¼Œç©¿è¼•è–„å³å¯ã€‚";
        else if (maxT <= 10) t += "å¤©å†·ï¼Œè¨˜å¾—ä¿æš–ã€‚";
        else t += "æ°£æº«èˆ’é©ï¼Œæ­£å¸¸ç©¿è‘—å³å¯ã€‚";
      } else {
        t += "æº«åº¦è³‡è¨Šä¸å®Œæ•´ã€‚";
      }

      return t;
    }

    // Dog walking advice - detailed
    function getDogAdvice(rainProb, minTemp, maxTemp, weatherDesc) {
      const rain = parseNumber(rainProb);
      const minT = parseNumber(minTemp);
      const maxT = parseNumber(maxTemp);
      const avg = (!Number.isNaN(minT) && !Number.isNaN(maxT)) ? Math.round((minT + maxT) / 2) : NaN;

      let text = "";
      let score = 3; // 1~5

      // rain
      if (!Number.isNaN(rain)) {
        if (rain >= 70) {
          text += "ğŸŒ§ï¸ å¤§é›¨ï¼šå»ºè­°ç¸®çŸ­æ•£æ­¥æˆ–æ”¹å®¤å…§æ´»å‹•ï¼Œå¤–å‡ºè«‹ç©¿é›¨è¡£ä¸¦æ³¨æ„æ³¥æ¿˜ã€‚";
          score = 1;
        } else if (rain >= 40) {
          text += "ğŸŒ¦ï¸ æœ‰é›¨æ©Ÿç‡ï¼šå»ºè­°æ”œå¸¶é›¨è¡£/é®é›¨è£å‚™ï¼Œè¦–æƒ…æ³çŸ­æš«æ•£æ­¥ã€‚";
          score = Math.min(score, 2);
        } else {
          text += "ğŸŒ¤ï¸ é™é›¨æ©Ÿç‡ä½ï¼Œé©åˆå¤–å‡ºæ•£æ­¥ã€‚";
          score = Math.max(score, 4);
        }
      } else {
        text += "ğŸŒ¤ï¸ é™é›¨è³‡è¨Šä¸è¶³ï¼Œè«‹è§€å¯Ÿå¯¦éš›å¤©æ°£ã€‚";
      }

      // temperature considerations
      if (!Number.isNaN(avg)) {
        if (avg >= 33) {
          text += "\nğŸ¥µ å¤ªç†±ï¼šé¿å…ä¸­åˆé«˜æº«æ™‚æ®µï¼Œé¸æ¸…æ™¨æˆ–å‚æ™šæ•£æ­¥ï¼Œä¸¦æ³¨æ„è£œæ°´ã€‚";
          score = Math.min(score, 1);
        } else if (avg >= 28) {
          text += "\nğŸ˜… åç†±ï¼šå»ºè­°é¸æ“‡è¼ƒé™°æ¶¼è·¯æ®µæˆ–è¼ƒæ¶¼æ™‚æ®µæ•£æ­¥ã€‚";
          score = Math.min(score, 2);
        } else if (avg <= 10) {
          text += "\nğŸ¥¶ åå†·ï¼šæ³¨æ„ä¿æš–ï¼ŒçŸ­æ™‚é–“å¤šæ¬¡æ•£æ­¥æ¯”ä¸€æ¬¡é•·æ™‚é–“æ›´å¥½ã€‚";
          score = Math.min(score, 2);
        } else {
          text += "\nğŸ˜Š èˆ’é©ï¼šæº«åº¦é©ä¸­ï¼Œç‚ºéå¸¸é©åˆæ•£æ­¥çš„å¤©æ°£ã€‚";
        }
      }

      // weatherDesc specifics
      if (typeof weatherDesc === "string") {
        if (weatherDesc.includes("é›·")) {
          text += "\nâš¡ æœ‰é›·ï¼šè«‹é¿å…å¤–å‡ºä»¥å…å±éšªã€‚";
          score = Math.min(score, 1);
        }
      }

      const paws = "ğŸ¾".repeat(Math.max(1, Math.min(5, score)));
      return `${paws}  æ•£æ­¥èˆ’é©åº¦ï¼š${score}/5\n\n${text}`;
    }

    // Short dog advice (for mini cards)
    function getShortDogAdvice(minTemp, maxTemp, rainProb) {
      const rain = parseNumber(rainProb);
      const minT = parseNumber(minTemp);
      const maxT = parseNumber(maxTemp);
      const avg = (!Number.isNaN(minT) && !Number.isNaN(maxT)) ? Math.round((minT+maxT)/2) : NaN;

      if (!Number.isNaN(rain) && rain >= 70) return "ğŸŒ§ï¸ å»ºè­°ç¸®çŸ­æ•£æ­¥";
      if (!Number.isNaN(rain) && rain >= 40) return "ğŸŒ¦ï¸ å¯èƒ½ä¸‹é›¨";
      if (!Number.isNaN(avg) && avg >= 33) return "ğŸ¥µ å¤ªç†±äº†";
      if (!Number.isNaN(avg) && avg <= 10) return "ğŸ¥¶ åå†·";
      return "ğŸ• é©åˆæ•£æ­¥";
    }

    // format time for display (if ISO timestamp)
    function formatTimeLabel(startTime) {
      if (!startTime) return "";
      try {
        const d = new Date(startTime);
        if (isNaN(d)) return startTime.slice(11,16) || startTime;
        return d.getHours().toString().padStart(2,'0') + ":" + d.getMinutes().toString().padStart(2,'0');
      } catch(e) {
        return startTime;
      }
    }

    // Render main hero + forecast
    function renderFromNormalized(norm) {
      const forecasts = norm.forecasts;
      if (!forecasts || forecasts.length === 0) {
        console.warn("Normalized data empty");
        alert("æŠ±æ­‰ï¼Œå¤©æ°£è³‡æ–™æ ¼å¼ç•°å¸¸ï¼Œç„¡æ³•é¡¯ç¤ºã€‚");
        document.getElementById("loading").style.display = "none";
        return;
      }

      const current = forecasts[0];
      // parse numeric
      const minT = parseNumber(current.minTemp);
      const maxT = parseNumber(current.maxTemp);
      const avgT = (!Number.isNaN(minT) && !Number.isNaN(maxT)) ? Math.round((minT + maxT) / 2) : current.minTemp || current.maxTemp || "--";

      // hero HTML
      const period = getTimePeriodFromStart(current.startTime);
      const heroHTML = `
        <div class="hero-period">${period}</div>
        <div class="weather-main">
          <div class="weather-icon">${getWeatherIcon(current.weather)}</div>
          <div class="temp">${avgT}Â°</div>
          <div class="desc">${current.weather}</div>
        </div>

        <div class="advice">${getHumanAdvice(current.rain, current.maxTemp)}</div>

        <div class="dog-walk-advice">
          <div class="dog-walk-advice-title">ğŸ• æŸ´çŠ¬æ•£æ­¥å»ºè­°</div>
          <div id="dog-advice-content">${getDogAdvice(current.rain, current.minTemp, current.maxTemp, current.weather)}</div>
        </div>
      `;
      document.getElementById('heroCard').innerHTML = heroHTML;

      // update top-right date
      const now = new Date();
      const days = ["é€±æ—¥","é€±ä¸€","é€±äºŒ","é€±ä¸‰","é€±å››","é€±äº”","é€±å…­"];
      document.getElementById('updateTime').textContent = `${now.getMonth()+1}æœˆ${now.getDate()}æ—¥ ${days[now.getDay()]}`;
      document.getElementById('todayDate').textContent = "";

      // render forecasts (others)
      const scroll = document.getElementById('futureForecasts');
      scroll.innerHTML = "";
      // start from index 1 (others)
      for (let i = 1; i < forecasts.length; i++) {
        const f = forecasts[i];
        const fDate = f.startTime ? new Date(f.startTime) : null;
        let label = getTimePeriodFromStart(f.startTime);
        if (fDate) {
          const today = new Date();
          if (fDate.getDate() !== today.getDate()) label = "æ˜å¤©" + label;
        }
        const card = document.createElement('div');
        card.className = 'forecast-card';
        card.innerHTML = `
          <div class="mini-time">${label}</div>
          <div class="mini-icon">${getWeatherIcon(f.weather)}</div>
          <div class="mini-temp">${f.minTemp}Â° - ${f.maxTemp}Â°</div>
          <div class="mini-rain">ğŸ’§ ${f.rain}%</div>
          <div class="forecast-walk">${getShortDogAdvice(f.minTemp, f.maxTemp, f.rain)}</div>
        `;
        scroll.appendChild(card);
      }
    }

    // Fetch and handle API (with minimum loading delay)
    async function fetchWeather() {
      const minDelay = new Promise(resolve => setTimeout(resolve, 1500));
      try {
        // fetch and parse json
        const fetchPromise = fetch(API_URL).then(res => {
          if (!res.ok) throw new Error('Network response was not ok: ' + res.status);
          return res.json();
        });

        // wait both
        const [json] = await Promise.all([fetchPromise, minDelay]);

        // normalize
        const norm = normalizeApiData(json);

        // If normalized forecasts empty, try alternative fallbacks and log original json
        if (!norm.forecasts || norm.forecasts.length === 0) {
          console.warn("normalizeApiData produced empty forecasts. Raw response:", json);
          alert("å–å¾—çš„å¤©æ°£æ ¼å¼ä¸ç¬¦åˆé æœŸï¼Œè«‹ç¨å¾Œå†è©¦æˆ–æª¢æŸ¥ APIã€‚");
          document.getElementById("loading").style.display = "none";
          return;
        }

        // render
        renderFromNormalized(norm);

        // hide loading
        document.getElementById('loading').style.display = 'none';
        document.getElementById('mainContent').style.display = 'block';
      } catch (err) {
        console.error("fetchWeather error:", err);
        alert("å¤©æ°£è³‡æ–™è®€å–å¤±æ•—ï¼ŒæŸ´æŸ´æŠŠç¶²è·¯ç·šå’¬æ–·äº†æˆ– API ç„¡å›æ‡‰ï¼");
        document.getElementById('loading').style.display = 'none';
      }
    }

    // init
    document.addEventListener('DOMContentLoaded', fetchWeather);
  </script>
</body>
</html>
